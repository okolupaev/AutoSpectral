<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>09 Per Cell Optimization • AutoSpectral</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="09 Per Cell Optimization">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">AutoSpectral</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/01_Full_AutoSpectral_Workflow.html">01 Full Workflow Example</a></li>
    <li><a class="dropdown-item" href="../articles/02_Control_File_example.html">02 Creating the control file</a></li>
    <li><a class="dropdown-item" href="../articles/03_Aurora_example.html">03 Aurora AutoSpectral Example</a></li>
    <li><a class="dropdown-item" href="../articles/04_ID7000_WLS_example.html">04 ID7000 WLS Example</a></li>
    <li><a class="dropdown-item" href="../articles/05_Preparing_Controls.html">05 Preparing Controls</a></li>
    <li><a class="dropdown-item" href="../articles/06_Gating.html">06 Gating</a></li>
    <li><a class="dropdown-item" href="../articles/07_Cleaning.html">07 Control clean-up</a></li>
    <li><a class="dropdown-item" href="../articles/08_Single_Cell_AutoFluorescence.html">08 Single Cell Autofluorescence</a></li>
    <li><a class="dropdown-item" href="../articles/09_Per_Cell_Optimization.html">09 Per Cell Optimization</a></li>
    <li><a class="dropdown-item" href="../articles/10_Reload_AutoSpectral.html">10 Re-running AutoSpectral</a></li>
    <li><a class="dropdown-item" href="../articles/11_Plotting.html">11 Plotting</a></li>
    <li><a class="dropdown-item" href="../articles/12_Speed_It_Up.html">12 Speed It Up (Why So Slow?)</a></li>
    <li><a class="dropdown-item" href="../articles/13_Updates_And_Issues.html">13 Updates and Issues</a></li>
    <li><a class="dropdown-item" href="../articles/14_Development.html">14 Development</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/DrCytometer/AutoSpectral/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>09 Per Cell Optimization</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/DrCytometer/AutoSpectral/blob/HEAD/vignettes/articles/09_Per_Cell_Optimization.Rmd" class="external-link"><code>vignettes/articles/09_Per_Cell_Optimization.Rmd</code></a></small>
      <div class="d-none name"><code>09_Per_Cell_Optimization.Rmd</code></div>
    </div>

    
    
<p>The aim of this article is to explain a bit more about how we go
about optimizing the fluorophore signatures used for unmixing on a
per-cell basis in AutoSpectral. Let me know if the explanation doesn’t
make sense. There are days when I think it’s really weird that we can
actually figure this stuff out from the data. Also, this is not the only
way of doing this, just the best one I’ve found so far.</p>
<p>Okay, so we’re basically going to play some Tetris with your
unmixing. You can also think of this as “theme and variations” if you’re
musically inclined, or multiverse unmixing, if you prefer comics.</p>
<p>The aim here is to deal with the inherent variability that exists in
the emissions from the fluorophores. This variability manifests at the
level of the cell (or particle/data point) as spread. Spread is a
population-level thing; individual cells do not have spread, they have
exact positions. We get spread in the unmixing (and compensation in
conventional flow) because we have a <em>distribution</em> of outcomes
in the spillover/spectra for the fluorophores and we unmix using only a
single (hopefully) best fit spectrum. This means there are data on both
sides of that single best fit (think of it as a median or average for
the distribution), both in the raw data and the unmixed. If there is a
mismatch between the single-colour control used to generate the
fluorophore’s spectrum and the actual data in the fully stained sample,
this will manifest as a skew in the distribution of the unmixed data
(i.e., unmixing error). These mismatches can occur for a multitude of
reasons, including tandem breakdown, improperly prepared controls,
bead-based controls, low brightness or autofluorescence (AF)
contamination of the spectrum. The first part of AutoSpectral–getting
the optimized single spectra using <code><a href="../reference/clean.controls.html">clean.controls()</a></code> and
<code><a href="../reference/get.fluorophore.spectra.html">get.fluorophore.spectra()</a></code>, gets you as far as it can with a
single spectrum per fluorophore. This is the next step.</p>
<p>What we are going to do is similar to what we did with the single
cell AF extraction. We will start by mapping the variation in the
single-color controls for each fluorophore using a self-organizing map
(SOM).</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span> <span class="va"><a href="https://github.com/DrCytometer/AutoSpectral" class="external-link">AutoSpectral</a></span> <span class="op">)</span></span></code></pre></div>
<p>If you haven’t already done so, you’ll need to run the basic
AutoSpectral workflow to get clean spectral signatures and
autofluorescence signatures. See the articles on this, including “Single
Cell Autofluorescence”.</p>
<p>The <code>af.spectra</code> here should match the source of your
cells in the single-colour controls. If you’re using beads for your
single colour controls, the <code>af.spectra</code> should match the
unstained sample that is provided as <code>AF</code> in the
<code>control.file</code>.</p>
<p>For this example, we’ll assume you’ve already run AutoSpectral to
extract both your fluorophore signatures and your autofluorescence
spectra. This should be quick. For <code><a href="../reference/read.spectra.html">read.spectra()</a></code>, change
the name of your files as appropriate. If they aren’t in the
<code>table_spectra</code> folder, change the location using the
<code>spectra.dir</code> argument.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">asp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get.autospectral.param.html">get.autospectral.param</a></span><span class="op">(</span> cytometer <span class="op">=</span> <span class="st">"aurora"</span>, figures <span class="op">=</span> <span class="cn">TRUE</span> <span class="op">)</span></span>
<span><span class="va">control.dir</span> <span class="op">&lt;-</span> <span class="st">"./SSC"</span></span>
<span><span class="va">control.file</span> <span class="op">&lt;-</span> <span class="st">"fcs_control_file.csv"</span></span>
<span><span class="va">spectra</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/read.spectra.html">read.spectra</a></span><span class="op">(</span> <span class="st">"Cells AF Removed autospectral spectra.csv"</span> <span class="op">)</span></span>
<span><span class="va">af.spectra</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/read.spectra.html">read.spectra</a></span><span class="op">(</span> <span class="st">"autospectral autofluorescence.csv"</span> <span class="op">)</span></span></code></pre></div>
<p>Now we are ready to go variant hunting.</p>
<p>For the variants, we’re going to load in the FCS file for each
single-colour control, identify the brightest non-autofluorescent events
in the peak channel, and cluster those to get variants.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">variants</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get.spectral.variants.html">get.spectral.variants</a></span><span class="op">(</span></span>
<span>   <span class="va">control.dir</span>,</span>
<span>   <span class="va">control.file</span>,</span>
<span>   <span class="va">asp</span>,</span>
<span>   <span class="va">spectra</span>,</span>
<span>   <span class="va">af.spectra</span>,</span>
<span>   parallel <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>   verbose <span class="op">=</span> <span class="cn">TRUE</span> </span>
<span><span class="op">)</span></span></code></pre></div>
<p>Set <code>parallel</code> to <code>TRUE</code> for faster processing.
This should take a couple of minutes.</p>
<p>This outputs a list containing: 1) The thresholds for positivity in
each unmixed channel, as determined by the 99.5th percentile on the
<code>AF</code> sample in <code>flow.control</code>. If you refer back
to your <code>control.file</code>, this will be whichever sample
contains “AF” as the fluorophore. This should be an unstained cell
control matching the single-colour controls in <code>control.file</code>
and hence <code>flow.control</code>. 2) A named list of matrices, one
per fluorophore in <code>flow.control</code>. Each matrix contains up to
100 spectra per fluorophore. This number can be adjusted by argument
<code>som.dim</code> to <code><a href="../reference/get.spectral.variants.html">get.spectral.variants()</a></code>, which is
by default <code>10</code>.</p>
<p>This is saved as an R object in a .rds file. This will be in the same
folder as the output plots, unless you change the specified location
using the argument <code>output.dir</code>. By default, you should get
“Spectral_variants.rds” in folder <code>figure_spectral_variants</code>.
This can be accessed later using the <code><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">readRDS()</a></code> base
function in R.</p>
<p>The variant spectra are QC’d against the optimized single spectrum
for that fluorophore, as defined in <code>spectra</code>. If
<code>spectra</code> don’t all look right, neither will the variants.
The QC is done by cosine similarity, with a default threshold set to
exclude anything less than 0.98.</p>
<p>It’s important to bear in mind that we’re only allowing variation
within the range seen in the single-colour control, nothing more.</p>
<p>We get output plots of the variant signatures, which should appear in
the <code>figure_spectral_variants</code> folder, unless you change the
<code>output.dir</code> argument from the default <code>NULL</code>.</p>
<p>Here’s what BUV661 really looks like, at least on the anti-mouse CD19
BUV661 I used in this experiment:</p>
<p><img src="figures/BUV661_variants.jpg" alt="BUV661 variability">
The dark blue trace is the optimized single spectrum from
<code>spectra</code>. The light blue region represents the range of
variation across all the variant spectra. Specifically, the min and max
for each channel are being plotted.</p>
<p>Notice that the main variation is in the R1 and R2 detectors,
indicative of variation in the direct excitation of the red
laser-excited acceptor molecule in BUV661. It’s hard to get good
information about the structure of the Brilliant dyes, but they’re long
polymers and all except for the shortest emission ones (e.g., BUV395,
BV421, BB515 and also BV510) are tandem dyes. BUV661 is probably a
tandem of BUV395 and something like Cy5. So, what we are seeing is
variation in the ratio of direct Cy5 excitation by the 561nm laser to
excitation of BUV395 by the 355nm laser. There are a lot of reasons why
this could be happening. One explanation that I consider to be likely is
that we have a distribution of species of BUV661 in the conjugated
antibody, either due to production variation (not so likely) or tandem
breakdown (more likely). When we stain our cells, the distribution of
conjugates on any given cell will give a certain result (think of 80
intact molecules and 20 somewhat broken ones on cell A, and perhaps
85:15 on cell B), which will result in a distribution at the population
level. There’s also electronic noise and measurement error in the mix.
Anyway, we get some cells with more red emission and some with less,
which will create variability in amount of red signal from BUV661. This
means that if we put a fluorophore in our unmixing that uses R1 and/or
R2 heavily, say APC, we will observe variability in the cells that are
positive for BUV661 with respect to APC. Hence, spillover spread. There
are some broader implications here for panel design and other issues in
the field, I think.</p>
<p>Here’s PE-Vio770 (anti-ACSA-2), which is essentially PE-Cy7. See that
there’s a wide light blue region around YG1, which is where the base
donor PE molecule emits. This means we have some tandem breakdown and
that there is a range of species in the vial. The variation in the
mid-UV, mid-violet and narrow-blue is AF.</p>
<div class="float">
<img src="figures/PE-Vio770_variants.jpg" alt="PE-Vio770 variation"><div class="figcaption">PE-Vio770 variation</div>
</div>
<p>Okay, now we’re ready to unmix with per-cell fluorophore
optimization.</p>
<p>This is where we start Tetrising.</p>
<p>We are going to try to figure out which of these variants is the best
“fit” for each cell in the data. We do this by trying to fill in the
little gaps, the mismatch, in between the raw data and the prediction
from the unmixing model. This gap is call the residual, which is the
part of the data that cannot be explained by the model. We want the
model to be as good as possible, which means minimizing that gap. One
way of thinking of the unmixing is that we are trying to squeeze the
spectra into the raw data. We can multiply them up and down to scale
them, but we don’t normally get to change the shapes at all. With the
variants, we have options, all of which are very, very similar, but that
small flex allows us to fit the shapes in better.</p>
<p>The most accurate way of doing this would be to test not only each
variant for each cell, but to test each <em>combination</em> of
variants, probably in an iterative refinement. Since that would increase
at the rate of n.variants^n.fluorophores, it is currently prohibitive to
do so. Note that this does not even begin to deal with variation outside
the range of what is seen in the single-stained controls. Up to version
1.0.0, AutoSpectral has used a “brute force” approach of testing every
variant for every cell, at least for the “slow” method. This is indeed
slow.</p>
<p>As of version 1.0.0, we speed up the process by pre-screening
variants per cell. We can do this by looking for variants where the
change in the spectrum between the variant and the base/median spectrum
for that fluorophore matches the shape of the residuals for the cell.
Basically, we are looking for alignment or similarity between what the
change in spectrum will do and what the cell has “left over”. This means
we’re only looking for variation that pushes in the “correct” direction.
By doing this, we can cut down to a handful of potential candidates (or
even a single one) rather than testing a hundred or so per fluorophore.
That allows us to speed things up a lot, without affecting the results
much at all. In some cases, this gives a slightly better result since we
don’t get trapped in local minima. Since we are no longer testing every
variant for every cell, we can pass a larger set of variants without
affecting the computation time much at all, and AutoSpectral offers that
in version 1.0.0. This can help slightly, but tends to be less important
than screening more autofluorescence spectra.</p>
<p>Anyway, running this in pure R is now possible, albeit slow. The
faster implementation is in C++ and requires installation of
<code>AutoSpectralRcpp</code>. I strongly encourage you to install that
prior to running unmixing as below. Also, be sure that you have the fast
BLAS and LAPACK installed. Please reach out if you have suggestions for
faster implementation (I’m not a computer scientist).</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span> <span class="va"><a href="https://github.com/DrCytometer/AutoSpectralRcpp" class="external-link">AutoSpectralRcpp</a></span> <span class="op">)</span></span>
<span></span>
<span><span class="va">fully.stained.dir</span> <span class="op">&lt;-</span> <span class="st">"./Fully stained"</span></span>
<span></span>
<span><span class="fu"><a href="../reference/unmix.fcs.html">unmix.fcs</a></span><span class="op">(</span> fcs.file <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/file.path.html" class="external-link">file.path</a></span><span class="op">(</span> <span class="va">fully.stained.dir</span>, <span class="st">"C3 Lung_GFP_003_Samples.fcs"</span> <span class="op">)</span>,</span>
<span>           spectra <span class="op">=</span> <span class="va">spectra</span>,</span>
<span>           asp <span class="op">=</span> <span class="va">asp</span>,</span>
<span>           flow.control <span class="op">=</span> <span class="va">flow.control</span>,</span>
<span>           method <span class="op">=</span> <span class="st">"AutoSpectral"</span>,</span>
<span>           af.spectra <span class="op">=</span> <span class="va">lung.af</span>,</span>
<span>           spectra.variants <span class="op">=</span> <span class="va">variants</span>,</span>
<span>           speed <span class="op">=</span> <span class="st">"fast"</span> <span class="op">)</span></span></code></pre></div>
<p>Setting the “speed” determines how many pre-screened candidate
variants will be tested per cell. The options are “fast” = 1, “medium” =
3, and “slow” = 10. This is based on quite a bit of testing with high
parameter data from the Aurora, ID7000 and S8. For data with messier
fluorophores (like that BUV661 above), using “slow” is likely to show
some improvement. If you are using more modern fluorophores, you may
find minimal difference now when using “fast”.</p>
<p>If you want to set the number of variants yourself, you can do this
by providing the “k” argument. This will override “speed”. In the call
below, for instance, we’ve requested to test up to 100 variants per cell
(depending on what’s actually available). This would be comparable to
the previous “slow” brute force approach.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/unmix.fcs.html">unmix.fcs</a></span><span class="op">(</span> fcs.file <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/file.path.html" class="external-link">file.path</a></span><span class="op">(</span> <span class="va">fully.stained.dir</span>, <span class="st">"C3 Lung_GFP_003_Samples.fcs"</span> <span class="op">)</span>,</span>
<span>           spectra <span class="op">=</span> <span class="va">spectra</span>,</span>
<span>           asp <span class="op">=</span> <span class="va">asp</span>,</span>
<span>           flow.control <span class="op">=</span> <span class="va">flow.control</span>,</span>
<span>           method <span class="op">=</span> <span class="st">"AutoSpectral"</span>,</span>
<span>           af.spectra <span class="op">=</span> <span class="va">lung.af</span>,</span>
<span>           spectra.variants <span class="op">=</span> <span class="va">variants</span>,</span>
<span>           k <span class="op">=</span> <span class="fl">100</span> <span class="op">)</span></span></code></pre></div>
<p>Note that the “fast” approach in version 1.0.0 is very different from
the “fast” approximation in earlier version of AutoSpectral. It is not
expected to produce any substantial discontinuities in the data–if you
see this, please reach out (data will be helpful in identifying any
issues).</p>
<p>Unmixed FCS files will appear in folder
<code>./autospectral_unmixed</code>.</p>
<p>Add a <code>file.suffix</code> argument if you want a tag on the FCS
file’s name to differentiate it from other versions.</p>
<p>To demonstrate the effectiveness and accuracy of this approach, we
created a set of synthetic data. In this 42-colour data set from the
Aurora, BUV661 and APC are used to detect CD19 and Foxp3, markers that
are not co-expressed. We created a set of data in silico where the raw
data for BUV661+ and APC+ events (based on OLS unmixing) were combined
or maintained as separate original events. In this way, ground truth is
available for BUV661+, APC+ and BUV661+APC+ events. When unmixed using
OLS, populations containing BUV661 suffered from misclassification with
respect to a positivity threshold for APC set based on a value double
that of the 99.5th percentile on the unstained sample. These false
positivity errors were reduced when per-cell spectral selection was
performed, and the median absolute deviation of ground truth BUV661+APC-
events in the APC channel was reduced from 2194 to 723.</p>
<p><img src="figures/Synthetic_perCell_fluor.jpg" alt="Synthetic per-cell fluorophore optimization"> Synthetic data
showing that per-cell optimization of the fluorophore signatures reduces
spillover spread.</p>
<p>Correspondingly, the cosine similarity between the model’s
predictions for BUV661 and the actual data for BUV661 was closer to 1
(identity), consistent with more accurate modelling of the underlying
data.</p>
<p><img src="figures/perCellFluor_similarity.jpg" alt="Matching the underlying spectrum"> Distribution of cosine
similarity values between the ground truth and the assigned spectrum for
BUV661. Comparison between standard OLS unmixing and AutoSpectral with
per-cell fluorophore optimization on synthetic data. Stats by
Komogorov-Smirnov test.</p>
  </main>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Oliver Burton, Adrian Liston.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
